# 二、源代码及注释

[TOC]

#### 2.1 filemanage.h

```c++
#ifndef FILEMANAGE_H
#define FILEMANAGE_H

#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
#include <io.h>//*********
using namespace std;

#include "main.h"
#include "KeyManage.h"
#include "mainwindow.h"

class FileManage
{
private:
    char* Output;

public:
    struct ModeUserIDPwd {
        string modeUserID;
        string modePwd;
    }modeUserIDPwd;

public:
    ~FileManage();
    void SignAndEncryptString(string pwd, string userID, string keyringDir);
    void DecryptAndVerifyString(string signedAndEncryptedMessage, string pwd, string userID);
    string SignAndEncryptSingle(string pwd, string filePath, string userID, string pathStringFile, string keyringDir);
    string SignAndEncryptMultiple(string pwd, string filePath, string userID, string pathStringFile, string keyringDir);
    //string SignAndEncryptMultiple(string pwd, string filePath, vector<string> allUsers, string userID, string pathStringFile, string keyringDir);
    bool VerifySingle(string pwd, string filePath, string userID, string pathStringFile, string keyringDir);
    bool Verify(string pwd, string filePath, string userID, string pathStringFile, string keyringDir);
    //bool Verify(string pwd, string filePath, vector<string> allUsers, string userID, string pathStringFile, string keyringDir);
};
#endif // FILEMANAGE_H

```

#### 2.2 global.h

```c++
#ifndef GLOBAL_H
#define GLOBAL_H

#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

#include "main.h"
#include "user.h"

#include <sstream>

string conbineStrings(string left, string right);
int createDirectoryByString(string path);
string globalGetUserName();

class Global
{
private:

public:
    string baseName = "D:\\";
    string folderName = "OpenPGP_File_Manage_show";
    string folderName1 = "Key";
    string folderName2 = "File";

    string pathString;
    string pathStringUser;
    string pathStringKey;
    string pathStringFile;

public:
    Global();
    void set_baseName();
    ~Global();
};



#endif // GLOBAL_H

```

#### 2.3 keymanage.h

```c++
#ifndef KEYMANAGE_H
#define KEYMANAGE_H


#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qkeymgr.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

#include "main.h"
#include "user.h"
#include "global.h"

class MyKeyMgr : public KeyMgr
{
public:
    virtual int FireKeyList(KeyMgrKeyListEventParams* e)
    {
        printf("%-58s %-8s %-12s\n", e->UserId(), e->KeyId(), e->HasSecretKey() ? "private" : "");
        //printf("%-58s %-8s %-12s\n", e->UserId, e->KeyId, e->HasSecretKey ? "private" : "");
        return 0;
    }
};

class KeyManage
{
private:
    struct KeyGlobal {
        string pathString;
        string pathStringUser;
        string pathStringKey;
        string pathStringFile;
    }keyGlobal;
    struct KeyUser {
        string userID;
    }keyUser;

    MyKeyMgr keymgr;

public:
    ~KeyManage();
    void init(Global global, User user);
    void GenerateKeyPairRSA(string userID, string pwd);
    void ExportPublicKey(string userID, string pwd);
    void ExportPrivateKey(string userID, string pwd);
    void KeyStoreListKeys(string pwd);


};


#endif // KEYMANAGE_H

```

#### 2.4 logindialog.h

```c++
#ifndef LOGINDIALOG_H
#define LOGINDIALOG_H

#include <QDialog>

namespace Ui {
class LoginDialog;
}

class LoginDialog : public QDialog
{
    Q_OBJECT

public:
    explicit LoginDialog(QWidget *parent = nullptr);
    ~LoginDialog();

signals:
    void login();

private slots:
    void on_pushButton_clicked();
    void loginSlot();

private:
    Ui::LoginDialog *ui;
};

#endif // LOGINDIALOG_H

```

#### 2.5 main.h

```c++
#ifndef MAIN_H
#define MAIN_H

#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

void WriteLine(string console);
string WcharToString(wchar_t wText[]);
#endif // MAIN_H

```

#### 2.6 mainwindow.h

```c++
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;



namespace Ui {
class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();
    void mainProcess();

private slots:
    void on_pushButton_clicked();
    void on_pushButton_2_clicked();

    void on_pushButton_3_clicked();

    void on_pushButton_4_clicked();

private:
    Ui::MainWindow *ui;
    string mykeyringdir;
    string aid;
    string apwd;
    QByteArray res;

    string aidSingle;
    string apwdSingle;
    string recipSingle;
    string signSingle;

    string inputfilepathEncryptSingle;

    string aidMultiple;
    string apwdMultiple;
    string recipMultiple;
    string signMultiple;





};

#endif // MAINWINDOW_H

```

#### 2.7 modemanage.h

```C++
#ifndef MODEMANAGE_H
#define MODEMANAGE_H

#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

#include "main.h"
#include "user.h"
#include "FileManage.h"
#include "global.h"

class ModeManage
{
private:
    struct ModeGlobal {
        string pathString;
        string pathStringUser;
        string pathStringKey;
        string pathStringFile;
    }modeGlobal;

public:
    ~ModeManage();
    int modeInput(Global global, User user);
    void modeControl(int mode, User user, string pwd);
};

#endif // MODEMANAGE_H

```

#### 2.8 user.h

```c++
#ifndef USER_H
#define USER_H

#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

#include <sstream>
#include "sddl.h"
#include "main.h"

template <typename T>
string ToString(T value)
{
    stringstream os;
    os << value;
    return os.str();
}


class User
{
private:
    string username;		//用户名
    PSID sid;		//用户安全标识符
    LPWSTR stringSid;  //用户安全标识符，LPWSTR格式
    string userID;
    vector<string> allAuthorizedUsers;
    vector<string> allAuthorizedUersPublicKey;  //所有用户目录文件

public:
    User();
    void currentUserInfo();
    string getUsername();
    PSID getSid();
    LPWSTR getStringSid();
    string getUserID();
    ~User();
};



#endif // USER_H


```

#### 2.9 filemanage.cpp

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

#include "main.h"
#include "global.h"
#include "FileManage.h"
#include "KeyManage.h"
#include "mainwindow.h"
#include <QString>
#include <QMessageBox>
#include <QLabel>
#include <QDebug>
#include <QStack>
#define LINE_LEN 100



FileManage::~FileManage()
{

}

void FileManage::SignAndEncryptString(string pwd, string userID, string keyringDir)
{
    OpenPGP pgp;
    MyKeyMgr keymgr;
    int ret_code = 0;
    char command[LINE_LEN];     // user's command
    char mykeyringDir[LINE_LEN];
    char passphrase[LINE_LEN];
    char privateKey[LINE_LEN];
    char recipientKey[LINE_LEN];
    char signerKey[LINE_LEN];

    string mykeyringdir="D:\\OpenPGP_File_Manage_show\\lenovo\\Key\\key-store";
    string aid="516";
    string apwd="561";

    strcpy(mykeyringDir,mykeyringdir.c_str());
    strcpy(passphrase,apwd.c_str());
    strcpy(privateKey,aid.c_str());
    strcpy(recipientKey,aid.c_str());
    strcpy(signerKey,aid.c_str());


/*
    printf("Keyring Directory: ");
    fgets(mykeyringDir, LINE_LEN, stdin);
    fgets(mykeyringDir, LINE_LEN, stdin);
    mykeyringDir[strlen(mykeyringDir) - 1] = '\0';
    keymgr.LoadKeyring(mykeyringDir);

    printf("\nPrivate Key User Id (Used to sign outgoing messages and decrypt incoming messages): ");
    fgets(privateKey, LINE_LEN, stdin);
    privateKey[strlen(privateKey) - 1] = '\0';
    printf("Passphrase: ");
    fgets(passphrase, LINE_LEN, stdin);
    passphrase[strlen(passphrase) - 1] = '\0';
    printf("Recipient Key User Id (Used to encrypt outgoing messages): ");
    fgets(recipientKey, LINE_LEN, stdin);
    recipientKey[strlen(recipientKey) - 1] = '\0';
    printf("Signer Key User Id (Used to verify the signature of an incoming message): ");
    fgets(signerKey, LINE_LEN, stdin);
    signerKey[strlen(signerKey) - 1] = '\0';
*/
    while (1)
    {
        pgp.Reset();

        printf("Please enter the message. When finished enter \":q\" on a line by itself:\n");
        char message[100];
        string msg;
        msg="6464848";
        strcpy(message,msg.c_str());
        /*
        message[0] = '\0';
        while (fgets(command, LINE_LEN, stdin))
        {
            command[strlen(command) - 1] = '\0';
            if (strcmp(command, ":q") == 0)
                break;
            strcat(message, command);
            strcat(message, "\n");
        }
        */
        pgp.SetInputMessage(message);


        if (strlen(privateKey) <= 0)
        {
            printf("Please select a private key.\n");
            break;
        }
        if (strlen(recipientKey) <= 0)
        {
            printf("Please select a recipient key.\n");
            break;
        }
        if (strlen(signerKey) <= 0)
        {
            printf("Please select a signer key.\n");
            break;
        }

        pgp.SetASCIIArmor(true);
        pgp.SetKeyCount(1);
        pgp.SetKeyKeyring(0, mykeyringDir);
        pgp.SetKeyUserId(0, privateKey);
        pgp.SetKeyPassphrase(0, passphrase);
        pgp.SetRecipientKeyCount(1);
        pgp.SetRecipientKeyKeyring(0, mykeyringDir);
        pgp.SetRecipientKeyUserId(0, recipientKey);
        pgp.SetOutputFile("D:\\OpenPGP_File_Manage_show\\lenovo\\File\\text4.gpg");
        ret_code = pgp.SignAndEncrypt();
        if (ret_code) goto done;

        //if (strlen(pgp.GetOutputFile()) <= 0)
        {
            printf("\nSigned & Encrypted Message:\n");
            //char* output;
            //int len;


            pgp.GetOutputMessage();
            //printf("%s\n", output);

            //output[strlen(output) - 1] = '\0';
            //pgp.SetInputMessage(output);

            //Output = output;
        }
/*
        //解密
        pgp.SetKeyCount(1);
        pgp.SetKeyKeyring(0, mykeyringDir);
        pgp.SetKeyUserId(0, privateKey);
        pgp.SetKeyPassphrase(0, passphrase);
        pgp.SetSignerKeyCount(1);
        pgp.SetSignerKeyKeyring(0, mykeyringDir);
        pgp.SetSignerKeyUserId(0, signerKey);
        ret_code = pgp.DecryptAndVerifySignature();
        if (ret_code) goto done;

        ret_code = pgp.DecryptAndVerifySignature();
        if (ret_code) goto done;

        //if (strlen(pgp.GetOutputFile()) <= 0)
        {
            printf("\nDecrypted & Verified Message:\n");
            char* output;
            int len;
            pgp.GetOutputMessage();
            printf("%s\n", output);
        }
*/
        break;
    }

done:
    if (ret_code)     // Got an error.  The user is done.
    {
        printf("\nError: %d", ret_code);
        //if (pgp.GetLastError())
        //{
        //    printf(" \"%s\"\n", pgp.GetLastError());
        //}
    }

}

```

#### 2.10 global.cpp

```c++
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

#include "main.h"
#include "user.h"
#include "global.h"

#include <sstream>

string conbineStrings(string left, string right)
{
    std::stringstream ss;
    ss << left << "\\" << right;
    return ss.str();
}

string globalGetUserName()
{
    string username;
    HANDLE hToken;
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        DWORD dwLengthNeeded;
        if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &dwLengthNeeded) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            PTOKEN_USER pTokenUser = (PTOKEN_USER)GlobalAlloc(GPTR, dwLengthNeeded);
            if (pTokenUser != NULL)
            {
                if (GetTokenInformation(hToken, TokenUser, pTokenUser, dwLengthNeeded, &dwLengthNeeded))
                {
                    SID_NAME_USE sidNameUse;

                    wchar_t szUserName[256];
                    DWORD dwUserNameSize = sizeof(szUserName);
                    wchar_t szDomainName[256];

                    DWORD dwDomainNameSize = sizeof(szDomainName);
                    PSID pSid = pTokenUser->User.Sid;
                    if (LookupAccountSid(NULL, pSid, szUserName, &dwUserNameSize, szDomainName, &dwDomainNameSize, &sidNameUse))
                    {
                        //wprintf(L"Current user: %s\\%s\n", szDomainName, szUserName);
                        //printf("Current user: %s\\%s\n", szDomainName, szUserName);

                        username = WcharToString(szUserName);
                    }
                }
                GlobalFree(pTokenUser);
            }
        }
        CloseHandle(hToken);
    }
    return username;
}

int createDirectoryByString(string path)
{
/*
* 在代码中，我们使用了MultiByteToWideChar函数来将路径参数从std::string类型转换为LPCWSTR类型。
* 该函数接受五个参数：源代码页（这里是CP_ACP，表示使用当前系统的ANSI代码页）、标志（这里是0）、
* 					源字符串的指针、源字符串的长度（这里使用-1表示自动计算）、目标缓冲区的指针和目标缓冲区的大小。
* 我们使用vector来创建一个足够大的缓冲区，并将其传递给MultiByteToWideChar函数。
* 最后，我们使用buffer.data()将缓冲区指针转换为LPCWSTR类型，并将其传递给CreateDirectory函数。

* 需要注意的是，如果您的路径包含非ANSI字符，则需要使用不同的代码页或不同的转换函数进行转换。
* 在这种情况下，建议查阅Windows API文档或相关资料，以了解正确的转换方式。
*
* 在代码中，我们使用了CreateDirectory函数的返回值来判断目录是否已存在。
* 如果CreateDirectory函数返回0，则检查错误码是否为ERROR_ALREADY_EXISTS或ERROR_PATH_NOT_FOUND。
* 如果错误码为ERROR_ALREADY_EXISTS，则说明目录已经存在，我们继续创建下一级目录。
* 如果错误码为ERROR_PATH_NOT_FOUND，则说明目录不存在，我们先创建该目录，然后继续创建下一级目录。
* 如果CreateDirectory函数成功返回，则将目录路径输出到控制台，并将路径后面添加一个路径分隔符以便于下一级目录的创建。

* 代码暂时没有处理输入路径为空字符串或只包含路径分隔符的情况，可以在后面添加相应的错误处理代码。
*/
    std::string delimiter = "\\";  // 定义路径分隔符
    size_t pos = 0;
    std::string token;
    std::vector<std::string> directories;

    while ((pos = path.find(delimiter)) != std::string::npos)
    {  // 使用路径分隔符进行分割
        token = path.substr(0, pos);
        directories.push_back(token);
        path.erase(0, pos + delimiter.length());
    }
    directories.push_back(path);  // 将最后一个目录添加到向量中

    std::string current_directory;
    for (const auto& directory : directories)
    {
        current_directory += directory;
        std::vector<wchar_t> buffer(current_directory.size() + 1);
        MultiByteToWideChar(CP_ACP, 0, current_directory.c_str(), -1, buffer.data(), static_cast<int>(buffer.size()));

        if (CreateDirectory(buffer.data(), NULL) == 0)
        {
            DWORD error_code = GetLastError();
            if (error_code == ERROR_ALREADY_EXISTS)
            {  // 目录已存在，继续创建下一级目录
                std::wcout << L"Directory already exists: " << buffer.data() << L"\n";
            }
            else if (error_code == ERROR_PATH_NOT_FOUND)
            {  // 目录不存在，创建目录并继续创建下一级目录
                if (CreateDirectory(buffer.data(), NULL) == 0)
                {
                    std::cout << "Failed to create directory!\n";
                    return 1;
                }
                std::wcout << L"Directory created successfully: " << buffer.data() << L"\n";
            }
            else
            {
                std::cout << "Failed to create directory!\n";
                return 1;
            }
        }
        else
        {
            std::wcout << L"Directory created successfully: " << buffer.data() << L"\n";
        }
        current_directory += "\\";
    }
}


Global::Global()
{
    WriteLine("");
    WriteLine("OpenPGP文件管理系统");
    WriteLine("");

    set_baseName();

    WriteLine("应用所创建的文件夹信息：");
    WriteLine(pathString);
    WriteLine(pathStringUser);
    WriteLine(pathStringKey);
    WriteLine(pathStringFile);

    createDirectoryByString(pathString);
    createDirectoryByString(pathStringUser);
    createDirectoryByString(pathStringKey);
    createDirectoryByString(pathStringFile);
}

void Global::set_baseName()
{
    WriteLine("请输入项目文件夹的存放位置，默认：D:\\，输入q可跳过。（各级目录间各用1个斜杠分隔）");
    string basename;
    basename = "q";
    //getline(cin, basename);

    if (basename != "q")
    {
        baseName = basename;
    }
    else
    {
        baseName = "D:";
    }

    pathString = conbineStrings(baseName, folderName);
    pathStringUser = conbineStrings(pathString, globalGetUserName());
    pathStringKey = conbineStrings(pathStringUser, folderName1);
    pathStringFile = conbineStrings(pathStringUser, folderName2);


}

Global::~Global()
{

}

```

#### 2.11 keymanage.cpp

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

#include "main.h"
#include "KeyManage.h"
#include "global.h"
#include "mainwindow.h"


KeyManage::~KeyManage()
{

}

void KeyManage::init(Global global, User user)
{
    keyGlobal.pathString = global.pathString;
    keyGlobal.pathStringFile = global.pathStringFile;
    keyGlobal.pathStringKey = global.pathStringKey;
    keyGlobal.pathStringUser = global.pathStringUser;

    keyUser.userID = user.getUserID();

}


void KeyManage::GenerateKeyPairRSA(string userID, string pwd)
{
    WriteLine("生成用户密钥");
    WriteLine("------------");

    string keyFile = conbineStrings(keyGlobal.pathStringKey, "key-store");
    createDirectoryByString(keyFile);

    string keyringDir = keyFile;

    keymgr.LoadKeyring(keyringDir.c_str());
    keymgr.ListKeys();

/*
* 此方法将当前密钥环保存到磁盘。 有两个输出选项。密钥环可以保存到单个密钥文件，也可以保存到目录中。
* 将密钥环保存到设置为路径的目录。该目录必须已存在。
* 该类将在指定目录中创建一个“pubring.gpg”和“secring.gpg”文件。如果文件已存在，它们将被覆盖。
* KeyringPath.
*/
    int ret_code = keymgr.CreateKey(userID.c_str(), pwd.c_str());

    if (ret_code == 0){
        cout << "Key has been generated! The UserID is: " << userID << ", The pwd is: " << pwd << endl;
    }

    int save_code = keymgr.SaveKeyring(keyringDir.c_str());
    if (save_code == 0)
        cout << "Key has been saved at: " << keyringDir << endl;




}

void KeyManage::ExportPublicKey(string userID, string pwd)
{
    string filePublicKkey = conbineStrings(keyGlobal.pathStringKey, "public-key-exported.asc");

    // should the exported files be ASCII or binary
    bool asciiArmored = true;

    // 新建或覆盖文件public-key-exported.asc，并导出公钥到文件，在filePublicKkey目录下
    keymgr.ExportPublicKey(filePublicKkey.c_str(), asciiArmored);


}

void KeyManage::ExportPrivateKey(string userID, string pwd)
{
    string filePrivateKkey = conbineStrings(keyGlobal.pathStringKey, "private-key-exported.asc");

    // should the exported files be ASCII or binary
    bool asciiArmored = true;

    // 新建或覆盖文件public-key-exported.asc，并导出公钥到文件，在filePublicKkey目录下
    keymgr.ExportSecretKey(filePrivateKkey.c_str(), asciiArmored);


}

void KeyManage::KeyStoreListKeys(string pwd)
{
    string keyFile = conbineStrings(keyGlobal.pathStringKey, "key-store");
    string keyringDir = keyFile;

    WriteLine("Listing Keys...");
    WriteLine("User Id------Key Id------Private Key");

    keymgr.LoadKeyring(keyringDir.c_str());
    keymgr.ListKeys();

    /*
    // 调试时，如需删除key，打开此注释
    while (1)
    {
        char userid[100];
        printf("User Id: ");
        fgets(userid, 100, stdin);
        userid[strlen(userid) - 1] = '\0';
        cout << keymgr.DeleteKey(userid) << endl;

        keymgr.SaveKeyring(keyringDir.c_str());

        keymgr.ListKeys();
    }
    */

}

```

#### 2.12 logindialog.cpp

```C++
#include "logindialog.h"
#include "ui_logindialog.h"
#include "qmessagebox.h"

LoginDialog::LoginDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::LoginDialog)
{
    ui->setupUi(this);

    QPixmap Images("C:\\Users\\lenovo\\Desktop\\cover.png");
    QPalette Palette = this->palette();
    Palette.setBrush(QPalette::Background, Images);
    this->setPalette(Palette);

    ui->pushButton->setStyleSheet(
        //正常状态样式
        "QPushButton{"
        "background-color:rgb(210,157,151);"//设置按钮背景色
        "border-radius:5px;"//设置圆角半径
        "color:white;"//设置按钮字体颜色
        "font-family: Helvetica;"
        "font-size: 12pt;"
        "font-weight: bold;"
        "}"

        //鼠标悬停样式
        "QPushButton:hover{"
        "background-color:#5f9ae6;"
        "color:white;"
        "}"

        //按钮按下样式
        "QPushButton:pressed{"
        /*背景颜色*/
        "background-color:rgb(14,145,208);"
        /*左内边距为3像素，让按下时字向右移动3像素*/
        "padding-left:3px;"
        /*上内边距为3像素，让按下时字向下移动3像素*/
        "padding-top:3px;"
        "}"
        );


    connect(this, &LoginDialog::login, this, &LoginDialog::loginSlot);
}

LoginDialog::~LoginDialog()
{
    delete ui;
}

void LoginDialog::on_pushButton_clicked()
{
    emit login();

}

void LoginDialog::loginSlot()
{
    QMessageBox::information(this, "Notice", "Login Successfully!");
    parentWidget()->show();
    this->hide();
}


```

#### 2.13 main.cpp

```c++
#include "mainwindow.h"
#include <QApplication>
#include "logindialog.h"
#include <qdesktopwidget.h>

#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;

    w.setWindowTitle("OpenPGP Folder Encryption Assistant");

    QDesktopWidget *desktop = QApplication::desktop();

    LoginDialog login(&w);
    login.setWindowTitle("login");
    login.show();
    //login.move((desktop->width() - login.width()) / 2, (desktop->height() - login.height()) / 2);

    return a.exec();





}

```

#### 2.14 mainwindow.cpp

```C++
#include "mainwindow.h"
#include "ui_mainwindow.h"

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")


#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

#include "user.h"
#include "global.h"
#include "KeyManage.h"
#include "ModeManage.h"
#include "sddl.h"
#include "filemanage.h"
#include <sstream>
#include <QScrollBar>
#include <QLineEdit>
#include <QLabel>
#define LINE_LEN 100

//用来打印信息的函数，方便不同环境下的修改
void WriteLine(string console)
{
    std::cout << console << endl;
}

//wchar_t变量转换为szDst
string WcharToString(wchar_t wText[])
{
    std::string szDst;
    DWORD dwNum = WideCharToMultiByte(CP_OEMCP, NULL, wText, -1, NULL, 0, NULL, FALSE);
    char* psText;
    psText = new char[dwNum];
    WideCharToMultiByte(CP_OEMCP, NULL, wText, -1, psText, dwNum, NULL, FALSE);
    szDst = psText;
    delete[]psText;

    return szDst;
}

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);


    mainProcess();

    QPixmap Images("C:\\Users\\lenovo\\Desktop\\mainbkg2.png");
    QPalette Palette = this->palette();
    Palette.setBrush(QPalette::Background, Images);
    this->setPalette(Palette);

    //QTextBrowser#textBrowser
    ui->textBrowser->setStyleSheet(
    "QTextBrowser{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"

    "QScrollBar:vertical{"
        "border: none;"
        "background: transparent;"
        "width: 6px;"
    "}"
    );

    ui->textBrowser_2->setStyleSheet(
    "QTextBrowser{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"

    "QScrollBar:vertical{"
        "border: none;"
        "background: transparent;"
        "width: 6px;"
    "}"
    );

    ui->textBrowser_3->setStyleSheet(
    "QTextBrowser{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"

    "QScrollBar:vertical{"
        "border: none;"
        "background: transparent;"
        "width: 6px;"
    "}"
    );

    ui->lineEdit->setStyleSheet(
    "QLineEdit{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"
    );

    ui->lineEdit_2->setStyleSheet(
    "QLineEdit{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"
    );

    ui->lineEdit_3->setStyleSheet(
    "QLineEdit{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"
    );

    ui->lineEdit_4->setStyleSheet(
    "QLineEdit{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"
    );

    ui->lineEdit_5->setStyleSheet(
    "QLineEdit{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"
    );

    ui->lineEdit_6->setStyleSheet(
    "QLineEdit{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"
    );

    ui->lineEdit_7->setStyleSheet(
    "QLineEdit{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"
    );

    ui->lineEdit_8->setStyleSheet(
    "QLineEdit{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"
    );

    ui->lineEdit_9->setStyleSheet(
    "QLineEdit{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"
    );

    ui->lineEdit_10->setStyleSheet(
    "QLineEdit{"
        "border:1px solid transparent;"
        "border-radius:2px;"
        "color: white;"
        "background-color: rgba(22,99,138,50%);"
        "border-color: rgba(0,156,255,50%);"
        "font-size: 14px;"
        "font-weight: 400;"
        "selection-background-color: #8c8c8c;"
        "selection-color:#e6e6e6;"
        "padding-left:6px;"
        "padding-right:6px;"
    "}"
    );

    ui->label->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_2->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_3->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_4->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_5->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_6->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_7->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_8->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_9->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_10->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_11->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_12->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_13->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_14->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_15->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );
    ui->label_16->setStyleSheet(
    "QLabel{"
        "color: white;"
        "font-family: SimHei;"
    "}"
    );

    ui->pushButton->setStyleSheet(
        //正常状态样式
        "QPushButton{"
        "background-color:rgb(179,179,255);"//设置按钮背景色
        "border-radius:5px;"//设置圆角半径
        "color:white;"//设置按钮字体颜色
        "font-family: SimHei;"
        "font-size: 9pt;"
        "}"

        //鼠标悬停样式
        "QPushButton:hover{"
        "background-color:#5f9ae6;"
        "color:white;"
        "}"

        //按钮按下样式
        "QPushButton:pressed{"
        /*背景颜色*/
        "background-color:rgb(14,145,208);"
        /*左内边距为3像素，让按下时字向右移动3像素*/
        "padding-left:3px;"
        /*上内边距为3像素，让按下时字向下移动3像素*/
        "padding-top:3px;"
        "}"
        );

    ui->pushButton_2->setStyleSheet(
        //正常状态样式
        "QPushButton{"
        "background-color:rgb(153,153,255);"//设置按钮背景色
        "border-radius:5px;"//设置圆角半径
        "color:white;"//设置按钮字体颜色
        "font-family: SimHei;"
        "font-size: 9pt;"
        "}"

        //鼠标悬停样式
        "QPushButton:hover{"
        "background-color:#5f9ae6;"
        "color:white;"
        "}"

        //按钮按下样式
        "QPushButton:pressed{"
        /*背景颜色*/
        "background-color:rgb(14,145,208);"
        /*左内边距为3像素，让按下时字向右移动3像素*/
        "padding-left:3px;"
        /*上内边距为3像素，让按下时字向下移动3像素*/
        "padding-top:3px;"
        "}"
        );

    ui->pushButton_3->setStyleSheet(
        //正常状态样式
        "QPushButton{"
        "background-color:rgb(102,102,255);"//设置按钮背景色
        "border-radius:5px;"//设置圆角半径
        "color:white;"//设置按钮字体颜色
        "font-family: SimHei;"
        "font-size: 9pt;"
        "}"

        //鼠标悬停样式
        "QPushButton:hover{"
        "background-color:#5f9ae6;"
        "color:white;"
        "}"

        //按钮按下样式
        "QPushButton:pressed{"
        /*背景颜色*/
        "background-color:rgb(14,145,208);"
        /*左内边距为3像素，让按下时字向右移动3像素*/
        "padding-left:3px;"
        /*上内边距为3像素，让按下时字向下移动3像素*/
        "padding-top:3px;"
        "}"
        );

    ui->pushButton_4->setStyleSheet(
        //正常状态样式
        "QPushButton{"
        "background-color:rgb(77,77,255);"//设置按钮背景色
        "border-radius:5px;"//设置圆角半径
        "color:white;"//设置按钮字体颜色
        "font-family: SimHei;"
        "font-size: 9pt;"
        "}"

        //鼠标悬停样式
        "QPushButton:hover{"
        "background-color:#5f9ae6;"
        "color:white;"
        "}"

        //按钮按下样式
        "QPushButton:pressed{"
        /*背景颜色*/
        "background-color:rgb(14,145,208);"
        /*左内边距为3像素，让按下时字向右移动3像素*/
        "padding-left:3px;"
        /*上内边距为3像素，让按下时字向下移动3像素*/
        "padding-top:3px;"
        "}"
        );


}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::mainProcess()
{


}

void MainWindow::on_pushButton_clicked()
{
    //展示文件夹创建
    Global global;

    //用户创建
    User user;
    string userID = user.getUserID();

    //密钥生成和导出

    KeyManage keyManage;
    keyManage.init(global, user);

    //密码唯一，且由用户的用户名和安全序列号唯一生成
    string pwd = ToString(hash<string>{}(user.getUsername()) ^ hash<PVOID>{}(user.getStringSid()));

    keyManage.GenerateKeyPairRSA(userID, pwd);
    keyManage.ExportPublicKey(userID, pwd);
    keyManage.ExportPrivateKey(userID, pwd);//私钥敏感信息不能导出
    keyManage.KeyStoreListKeys(pwd);

    QString tbu, tbp;
    tbu = QString::fromStdString(userID);
    tbp = QString::fromStdString(pwd);
    ui->textBrowser_3->setText("Key has been generated! The UserID is: " + tbu + ", The pwd is: " + tbp);

    //模式选择：原理展示/存储模式/调阅模式
    //用户界面
    while (true)
    {
        ModeManage modeManage;
        int Mode = modeManage.modeInput(global, user);
        Mode = 1;
        //modeManage.modeControl(Mode, user, pwd);
        //modeManage.modeControl(Mode, user, pwd);

        OpenPGP pgp;
        MyKeyMgr keymgr;
        int ret_code = 0;
        char command[LINE_LEN];     // user's command
        char mykeyringDir[LINE_LEN];
        char passphrase[LINE_LEN];
        char privateKey[LINE_LEN];
        char recipientKey[LINE_LEN];
        char signerKey[LINE_LEN];


        QString tempmykeyringdir = ui->lineEdit->text();
        mykeyringdir = tempmykeyringdir.toStdString();
        //string mykeyringdir="D:\\OpenPGP_File_Manage_show\\lenovo\\Key\\key-store";

        QString aidtemp = ui->lineEdit_2->text();
        aid = aidtemp.toStdString();
        QString apwdtemp = ui->lineEdit_3->text();
        apwd = apwdtemp.toStdString();

        strcpy(mykeyringDir,mykeyringdir.c_str());
        strcpy(passphrase,apwd.c_str());
        strcpy(privateKey,aid.c_str());
        strcpy(recipientKey,aid.c_str());
        strcpy(signerKey,aid.c_str());


    /*
        printf("Keyring Directory: ");
        fgets(mykeyringDir, LINE_LEN, stdin);
        fgets(mykeyringDir, LINE_LEN, stdin);
        mykeyringDir[strlen(mykeyringDir) - 1] = '\0';
        keymgr.LoadKeyring(mykeyringDir);

        printf("\nPrivate Key User Id (Used to sign outgoing messages and decrypt incoming messages): ");
        fgets(privateKey, LINE_LEN, stdin);
        privateKey[strlen(privateKey) - 1] = '\0';
        printf("Passphrase: ");
        fgets(passphrase, LINE_LEN, stdin);
        passphrase[strlen(passphrase) - 1] = '\0';
        printf("Recipient Key User Id (Used to encrypt outgoing messages): ");
        fgets(recipientKey, LINE_LEN, stdin);
        recipientKey[strlen(recipientKey) - 1] = '\0';
        printf("Signer Key User Id (Used to verify the signature of an incoming message): ");
        fgets(signerKey, LINE_LEN, stdin);
        signerKey[strlen(signerKey) - 1] = '\0';
    */
        while (1)
        {
            pgp.Reset();

            printf("Please enter the message. When finished enter \":q\" on a line by itself:\n");
            char message[100];
            string msg;
            msg = "this is the original message";
            strcpy(message,msg.c_str());

            /*
            message[0] = '\0';
            while (fgets(command, LINE_LEN, stdin))
            {
                command[strlen(command) - 1] = '\0';
                if (strcmp(command, ":q") == 0)
                    break;
                strcat(message, command);
                strcat(message, "\n");
            }
            */
            pgp.SetInputMessage(message);


            if (strlen(privateKey) <= 0)
            {
                printf("Please select a private key.\n");
                break;
            }
            if (strlen(recipientKey) <= 0)
            {
                printf("Please select a recipient key.\n");
                break;
            }
            if (strlen(signerKey) <= 0)
            {
                printf("Please select a signer key.\n");
                break;
            }

            pgp.SetASCIIArmor(false);
            pgp.SetKeyCount(1);
            pgp.SetKeyKeyring(0, mykeyringDir);
            pgp.SetKeyUserId(0, privateKey);
            pgp.SetKeyPassphrase(0, passphrase);
            pgp.SetRecipientKeyCount(1);
            pgp.SetRecipientKeyKeyring(0, mykeyringDir);
            pgp.SetRecipientKeyUserId(0, recipientKey);

            string outputfilepath = "D:\\OpenPGP_File_Manage_show\\lenovo\\File\\" + userID + "Encrypted.gpg";
            QString Qoutputfilepath = QString::fromStdString(outputfilepath);
            pgp.SetOutputFile(Qoutputfilepath);
            ret_code = pgp.SignAndEncrypt();
            if (ret_code) goto done;

            pgp.SetASCIIArmor(true);
            string outputfilepathASCII = "D:\\OpenPGP_File_Manage_show\\lenovo\\File\\" + userID + "ASCIIEncrypted.gpg";
            QString QoutputfilepathASCII = QString::fromStdString(outputfilepathASCII);
            pgp.SetOutputFile(QoutputfilepathASCII);
            ret_code = pgp.SignAndEncrypt();

            //if (strlen(pgp.GetOutputFile()) <= 0)
            {
                printf("\nSigned & Encrypted Message:\n");
                //char* output;
                //int len;
                res = pgp.GetOutputMessage();


                //pgp.GetOutputMessage();
                //printf("%s\n", output);

                //output[strlen(output) - 1] = '\0';
                //pgp.SetInputMessage(output);

                //Output = output;
            }

            QString data;
            QFile file(QoutputfilepathASCII); //path是文件的路径
            if(!file.open(QIODevice::ReadOnly | QIODevice::Text))
            {
                qDebug()<<"文件未打开!";
            }
            while(!file.atEnd())
            {
                QByteArray array = file.readLine();
                QString str(array);
               // qDebug()<< str;
                data.append(str);
            }
            ui->textBrowser->setText(data);

            //解密
            pgp.SetInputFile(Qoutputfilepath);
            pgp.SetKeyCount(1);
            pgp.SetKeyKeyring(0, mykeyringDir);
            pgp.SetKeyUserId(0, privateKey);
            pgp.SetKeyPassphrase(0, passphrase);
            pgp.SetSignerKeyCount(1);
            pgp.SetSignerKeyKeyring(0, mykeyringDir);
            pgp.SetSignerKeyUserId(0, signerKey);

            string outputfilepathDecrypt = "D:\\OpenPGP_File_Manage_show\\lenovo\\File\\" + userID + "Decrypted.txt";
            QString QoutputfilepathDecrypt = QString::fromStdString(outputfilepathDecrypt);
            pgp.SetOutputFile(QoutputfilepathDecrypt);

            ret_code = pgp.DecryptAndVerifySignature();
            if (ret_code) goto done;

            //if (strlen(pgp.GetOutputFile()) <= 0)
            {
                printf("\nDecrypted & Verified Message:\n");
                pgp.GetOutputMessage();
            }

            QString dataDecrypt;
            QFile fileDecrypt(QoutputfilepathDecrypt); //path是文件的路径
            if(!fileDecrypt.open(QIODevice::ReadOnly | QIODevice::Text))
            {
                qDebug()<<"文件未打开!";
            }
            while(!fileDecrypt.atEnd())
            {
                QByteArray array = fileDecrypt.readLine();
                QString str(array);
               // qDebug() << str;
                dataDecrypt.append(str);
            }
            ui->textBrowser_2->setText(dataDecrypt);

            break;
        }

    done:
        if (ret_code)     // Got an error.  The user is done.
        {
            printf("\nError: %d", ret_code);
            ui->textBrowser->setText(pgp.GetLastError());
            //if (pgp.GetLastError())
            //{
            //    printf(" \"%s\"\n", pgp.GetLastError());
            //}
        }


        WriteLine("程序已结束，按q退出，按其他任意键返回用户界面...");
        string quit;
        quit = "q";
        //cin >> quit;
        if (quit == "q")
            break;
    }
}

void MainWindow::on_pushButton_2_clicked()
{
    //展示文件夹创建
    Global global;

    //用户创建
    User user;
    string userID = user.getUserID();

    //密钥生成和导出

    KeyManage keyManage;
    keyManage.init(global, user);

    //密码唯一，且由用户的用户名和安全序列号唯一生成
    string pwd = ToString(hash<string>{}(user.getUsername()) ^ hash<PVOID>{}(user.getStringSid()));

    keyManage.GenerateKeyPairRSA(userID, pwd);
    keyManage.ExportPublicKey(userID, pwd);
    keyManage.ExportPrivateKey(userID, pwd);//私钥敏感信息不能导出
    keyManage.KeyStoreListKeys(pwd);

    QString tbu, tbp;
    tbu = QString::fromStdString(userID);
    tbp = QString::fromStdString(pwd);
    ui->textBrowser_3->setText("Key has been generated! The UserID is: " + tbu + ", The pwd is: " + tbp);


    //模式选择：原理展示/存储模式/调阅模式
    //用户界面
    while (true)
    {
        ModeManage modeManage;
        int Mode = modeManage.modeInput(global, user);
        Mode = 21;
        //modeManage.modeControl(Mode, user, pwd);
        //modeManage.modeControl(Mode, user, pwd);

        string keyringDir = conbineStrings(global.pathStringKey, "key-store");

        string newFile = ToString(userID) + "EncryptedSingle.gpg"; //生成文件名为 userID + Encrypted.gpg
        string outputFile = conbineStrings(global.pathStringFile, newFile);

        char mykeyringDir[LINE_LEN];
        char passphrase[LINE_LEN];
        char privateKey[LINE_LEN];
        char recipientKey[LINE_LEN];
        char signerKey[LINE_LEN];

        QString tempmykeyringdir = ui->lineEdit->text();
        mykeyringdir = tempmykeyringdir.toStdString();
        //string mykeyringdir="D:\\OpenPGP_File_Manage_show\\lenovo\\Key\\key-store";

        QString aidtempSingle = ui->lineEdit_2->text();
        aidSingle = aidtempSingle.toStdString();
        QString apwdtempSingle = ui->lineEdit_3->text();
        apwdSingle = apwdtempSingle.toStdString();

        QString reciptempSingle = ui->lineEdit_4->text();
        recipSingle = reciptempSingle.toStdString();
        QString signtempSingle = ui->lineEdit_5->text();
        signSingle = signtempSingle.toStdString();

        strcpy(mykeyringDir,mykeyringdir.c_str());
        strcpy(passphrase,apwdSingle.c_str());
        strcpy(privateKey,aidSingle.c_str());
        strcpy(recipientKey,recipSingle.c_str());
        strcpy(signerKey,signSingle.c_str());


    /*
        printf("\nPrivate Key User Id (Used to sign outgoing messages and decrypt incoming messages): ");
        fgets(privateKey, LINE_LEN, stdin);
        privateKey[strlen(privateKey) - 1] = '\0';
        printf("Passphrase: ");
        fgets(passphrase, LINE_LEN, stdin);
        passphrase[strlen(passphrase) - 1] = '\0';
        printf("Recipient Key User Id (Used to encrypt outgoing messages): ");
        fgets(recipientKey, LINE_LEN, stdin);
        recipientKey[strlen(recipientKey) - 1] = '\0';
        printf("Signer Key User Id (Used to verify the signature of an incoming message): ");
        fgets(signerKey, LINE_LEN, stdin);
        signerKey[strlen(signerKey) - 1] = '\0';
    */
        //modeUserIDPwd.modeUserID = privateKey;
        //modeUserIDPwd.modePwd = passphrase;

        char inFileEncryptSingle[LINE_LEN];
        QString QinputfilepathEncryptSingle = ui->lineEdit_10->text();
        inputfilepathEncryptSingle = QinputfilepathEncryptSingle.toStdString();


        QString QoutputfilepathEncryptSingle = QString::fromStdString(outputFile);

        OpenPGP pgp;

        size_t size = inputfilepathEncryptSingle.length();
        std::vector<wchar_t> buffer(inputfilepathEncryptSingle.size() + 1);
        MultiByteToWideChar(CP_ACP, 0, inputfilepathEncryptSingle.c_str(), -1, buffer.data(), static_cast<int>(buffer.size()));

        // 打开文件句柄
        HANDLE hFile = CreateFile(buffer.data(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            std::cerr << "Failed to open file." << std::endl;
        }

        // 创建文件映射对象
        HANDLE hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if (hMapFile == NULL) {
            std::cerr << "Failed to create file mapping object." << std::endl;
            CloseHandle(hFile);
        }

        // 映射文件到进程地址空间
        LPVOID lpMapView = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
        if (lpMapView == NULL) {
            std::cerr << "Failed to map view of file." << std::endl;
            CloseHandle(hMapFile);
            CloseHandle(hFile);
        }

        // 从内存中读取文件
        char* pBuffer = static_cast<char*>(lpMapView);
        std::cout << "Content of the file:" << std::endl;
        std::cout << pBuffer << std::endl;

        std::cout << "Succeeded in overwriting the mapped view of the file!" << std::endl;


        pgp.SetInputMessage(pBuffer);
        pgp.SetOutputFile(QoutputfilepathEncryptSingle);

        pgp.SetASCIIArmor(false);
        pgp.SetOverwrite(true);//覆盖写
        pgp.SetKeyCount(1);
        pgp.SetKeyKeyring(0, mykeyringDir);
        pgp.SetKeyUserId(0, privateKey);
        pgp.SetKeyPassphrase(0, passphrase);
        pgp.SetRecipientKeyCount(1);
        pgp.SetRecipientKeyKeyring(0, mykeyringDir);
        pgp.SetRecipientKeyUserId(0, recipientKey);

        int ret_code = pgp.SignAndEncrypt();

        pgp.GetOutputFile();

        ui->textBrowser->setText("单用户文件存储成功！存储位置："+QoutputfilepathEncryptSingle);

        cout << ret_code << endl;
        if (ret_code)     // Got an error.  The user is done.
        {
            printf("\nError: %d", ret_code);
            /*if (pgp.GetLastError())
            {
                printf(" \"%s\"\n", pgp.GetLastError());
            }*/
        }


        string outputfilepathMultipleDecrypt = "D:\\OpenPGP_File_Manage_show\\lenovo\\File\\" + userID + "SingleDecrypted.txt";
        QString QoutputfilepathMultipleDecrypt = QString::fromStdString(outputfilepathMultipleDecrypt);

        pgp.SetOverwrite(1);
        pgp.SetInputFile(QoutputfilepathEncryptSingle);
        pgp.SetOutputFile(QoutputfilepathMultipleDecrypt);

        pgp.SetKeyCount(1);
        pgp.SetKeyKeyring(0, mykeyringDir);
        pgp.SetKeyUserId(0, privateKey);
        pgp.SetKeyPassphrase(0, passphrase);
        pgp.SetSignerKeyCount(1);
        pgp.SetSignerKeyKeyring(0, mykeyringDir);
        pgp.SetSignerKeyUserId(0, signerKey);
        int ret_code_mul = pgp.DecryptAndVerifySignature();

        pgp.GetOutputFile();

        QString dataDecrypt;
        QFile fileDecrypt(QoutputfilepathMultipleDecrypt); //path是文件的路径
        if(!fileDecrypt.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            qDebug()<<"文件未打开!";
        }
        while(!fileDecrypt.atEnd())
        {
            QByteArray array = fileDecrypt.readLine();
            QString str(array);
           // qDebug() << str;
            dataDecrypt.append(str);
        }

        ui->textBrowser_2->setText("单用户文件真实性认证完成、解密成功！解密文件存储位置："+QoutputfilepathMultipleDecrypt+"\n\n解密结果是："+dataDecrypt);

        // 覆盖文件映射的地址空间
        // SecureZeroMemory(lpMapView, GetFileSize(hFile, NULL));

        // 关闭文件映射
        UnmapViewOfFile(lpMapView);
        CloseHandle(hMapFile);

        // 关闭文件句柄
        CloseHandle(hFile);



        break;
    }



}




/*
QTextBrowser QScrollBar::handle:vertical
{
    background-color: rgb(13,74,107);
    min-height: 30px;
    border-radius:3px;
    width: 6px;
}

QTextBrowser QScrollBar::add-line:vertical
{
   border: none;
   height: 0px;
 }

QTextBrowser QScrollBar::sub-line:vertical
{
   border: none;
   height: 0px;
}

QTextBrowser QScrollBar::add-page:vertical,QScrollBar::sub-page:vertical
{
    background:transparent;
    border-radius:3px;
}
*/



void MainWindow::on_pushButton_3_clicked()
{
    //展示文件夹创建
    Global global;

    //用户创建
    User user;
    string userID = user.getUserID();

    //密钥生成和导出

    KeyManage keyManage;
    keyManage.init(global, user);

    //密码唯一，且由用户的用户名和安全序列号唯一生成
    string pwd = ToString(hash<string>{}(user.getUsername()) ^ hash<PVOID>{}(user.getStringSid()));

    keyManage.GenerateKeyPairRSA(userID, pwd);
    keyManage.ExportPublicKey(userID, pwd);
    keyManage.ExportPrivateKey(userID, pwd);//私钥敏感信息不能导出
    keyManage.KeyStoreListKeys(pwd);

    QString tbu, tbp;
    tbu = QString::fromStdString(userID);
    tbp = QString::fromStdString(pwd);
    ui->textBrowser_3->setText("Key has been generated! The UserID is: " + tbu + ", The pwd is: " + tbp);


    //模式选择：原理展示/存储模式/调阅模式
    //用户界面
    while (true)
    {
        ModeManage modeManage;
        int Mode = modeManage.modeInput(global, user);
        Mode = 22;
        //modeManage.modeControl(Mode, user, pwd);
        //modeManage.modeControl(Mode, user, pwd);

        string keyringDir = conbineStrings(global.pathStringKey, "key-store");

        string newFile = ToString(userID) + "EncryptedMultiple.gpg"; //生成文件名为 userID + Encrypted.gpg
        string outputFile = conbineStrings(global.pathStringFile, newFile);

        char mykeyringDir[LINE_LEN];
        char passphrase[LINE_LEN];
        char privateKey[LINE_LEN];
        char recipientKey[LINE_LEN];
        char signerKey[LINE_LEN];

        QString tempmykeyringdir = ui->lineEdit->text();
        mykeyringdir = tempmykeyringdir.toStdString();
        //string mykeyringdir="D:\\OpenPGP_File_Manage_show\\lenovo\\Key\\key-store";

        QString aidtempSingle = ui->lineEdit_2->text();
        aidSingle = aidtempSingle.toStdString();
        QString apwdtempSingle = ui->lineEdit_3->text();
        apwdSingle = apwdtempSingle.toStdString();

        QString reciptempSingle = ui->lineEdit_4->text();
        recipSingle = reciptempSingle.toStdString();
        QString signtempSingle = ui->lineEdit_5->text();
        signSingle = signtempSingle.toStdString();

        strcpy(mykeyringDir,mykeyringdir.c_str());
        strcpy(passphrase,apwdSingle.c_str());
        strcpy(privateKey,aidSingle.c_str());
        strcpy(recipientKey,recipSingle.c_str());
        strcpy(signerKey,signSingle.c_str());


    /*
        printf("\nPrivate Key User Id (Used to sign outgoing messages and decrypt incoming messages): ");
        fgets(privateKey, LINE_LEN, stdin);
        privateKey[strlen(privateKey) - 1] = '\0';
        printf("Passphrase: ");
        fgets(passphrase, LINE_LEN, stdin);
        passphrase[strlen(passphrase) - 1] = '\0';
        printf("Recipient Key User Id (Used to encrypt outgoing messages): ");
        fgets(recipientKey, LINE_LEN, stdin);
        recipientKey[strlen(recipientKey) - 1] = '\0';
        printf("Signer Key User Id (Used to verify the signature of an incoming message): ");
        fgets(signerKey, LINE_LEN, stdin);
        signerKey[strlen(signerKey) - 1] = '\0';
    */
        //modeUserIDPwd.modeUserID = privateKey;
        //modeUserIDPwd.modePwd = passphrase;

        char inFileEncryptSingle[LINE_LEN];
        QString QinputfilepathEncryptSingle = ui->lineEdit_10->text();
        inputfilepathEncryptSingle = QinputfilepathEncryptSingle.toStdString();

        QString QoutputfilepathEncryptSingle = QString::fromStdString(outputFile);

        OpenPGP pgp;

        size_t size = inputfilepathEncryptSingle.length();
        std::vector<wchar_t> buffer(inputfilepathEncryptSingle.size() + 1);
        MultiByteToWideChar(CP_ACP, 0, inputfilepathEncryptSingle.c_str(), -1, buffer.data(), static_cast<int>(buffer.size()));

        // 打开文件句柄
        HANDLE hFile = CreateFile(buffer.data(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            std::cerr << "Failed to open file." << std::endl;
        }

        // 创建文件映射对象
        HANDLE hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if (hMapFile == NULL) {
            std::cerr << "Failed to create file mapping object." << std::endl;
            CloseHandle(hFile);
        }

        // 映射文件到进程地址空间
        LPVOID lpMapView = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
        if (lpMapView == NULL) {
            std::cerr << "Failed to map view of file." << std::endl;
            CloseHandle(hMapFile);
            CloseHandle(hFile);
        }

        // 从内存中读取文件
        char* pBuffer = static_cast<char*>(lpMapView);
        std::cout << "Content of the file:" << std::endl;
        std::cout << pBuffer << std::endl;

        std::cout << "Succeeded in overwriting the mapped view of the file!" << std::endl;

        pgp.SetInputMessage(pBuffer);
        pgp.SetOutputFile(QoutputfilepathEncryptSingle);

        pgp.SetASCIIArmor(false);
        pgp.SetOverwrite(true);//覆盖写
        pgp.SetKeyCount(1);
        pgp.SetKeyKeyring(0, mykeyringDir);
        pgp.SetKeyUserId(0, privateKey);
        pgp.SetKeyPassphrase(0, passphrase);
        pgp.SetRecipientKeyCount(1);
        pgp.SetRecipientKeyKeyring(0, mykeyringDir);
        pgp.SetRecipientKeyUserId(0, recipientKey);

        int ret_code = pgp.SignAndEncrypt();

        pgp.GetOutputFile();

        ui->textBrowser->setText("多用户文件存储成功！存储位置："+QoutputfilepathEncryptSingle);

        cout << ret_code << endl;
        if (ret_code)     // Got an error.  The user is done.
        {
            printf("\nError: %d", ret_code);
            /*if (pgp.GetLastError())
            {
                printf(" \"%s\"\n", pgp.GetLastError());
            }*/
        }

        char passphrase2[LINE_LEN];
        char privateKey2[LINE_LEN];
        char recipientKey2[LINE_LEN];
        char signerKey2[LINE_LEN];

        QString aidtempMultiple = ui->lineEdit_8->text();
        aidMultiple = aidtempMultiple.toStdString();
        QString apwdtempMultiple = ui->lineEdit_7->text();
        apwdMultiple = apwdtempMultiple.toStdString();

        QString reciptempMultiple = ui->lineEdit_6->text();
        recipMultiple = reciptempMultiple.toStdString();
        QString signtempMultiple = ui->lineEdit_9->text();
        signMultiple = signtempMultiple.toStdString();

        strcpy(passphrase2,apwdMultiple.c_str());
        strcpy(privateKey2,aidMultiple.c_str());
        strcpy(recipientKey2,recipMultiple.c_str());
        strcpy(signerKey2,signMultiple.c_str());


        string outputfilepathMultipleDecrypt = "D:\\OpenPGP_File_Manage_show\\lenovo\\File\\" + userID + "MultipleDecrypted.txt";
        QString QoutputfilepathMultipleDecrypt = QString::fromStdString(outputfilepathMultipleDecrypt);

        pgp.SetOverwrite(1);
        pgp.SetInputFile(QoutputfilepathEncryptSingle);
        pgp.SetOutputFile(QoutputfilepathMultipleDecrypt);

        pgp.SetKeyCount(1);
        pgp.SetKeyKeyring(0, mykeyringDir);
        pgp.SetKeyUserId(0, privateKey2);
        pgp.SetKeyPassphrase(0, passphrase2);
        pgp.SetSignerKeyCount(1);
        pgp.SetSignerKeyKeyring(0, mykeyringDir);
        pgp.SetSignerKeyUserId(0, signerKey2);
        int ret_code_mul = pgp.DecryptAndVerifySignature();

        pgp.GetOutputFile();

        QString dataDecrypt;
        QFile fileDecrypt(QoutputfilepathMultipleDecrypt); //path是文件的路径
        if(!fileDecrypt.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            qDebug()<<"文件未打开!";
        }
        while(!fileDecrypt.atEnd())
        {
            QByteArray array = fileDecrypt.readLine();
            QString str(array);
           // qDebug() << str;
            dataDecrypt.append(str);
        }

        ui->textBrowser_2->setText("多用户文件真实性认证完成、解密成功！解密文件存储位置："+QoutputfilepathMultipleDecrypt+"\n\n解密结果是："+dataDecrypt);

        // 覆盖文件映射的地址空间
        // SecureZeroMemory(lpMapView, GetFileSize(hFile, NULL));

        // 关闭文件映射
        UnmapViewOfFile(lpMapView);
        CloseHandle(hMapFile);

        // 关闭文件句柄
        CloseHandle(hFile);

        break;
    }
}

void MainWindow::on_pushButton_4_clicked()
{
    //展示文件夹创建
    Global global;

    //用户创建
    User user;
    string userID = user.getUserID();

    //密钥生成和导出

    KeyManage keyManage;
    keyManage.init(global, user);

    //密码唯一，且由用户的用户名和安全序列号唯一生成
    string pwd = ToString(hash<string>{}(user.getUsername()) ^ hash<PVOID>{}(user.getStringSid()));

    keyManage.GenerateKeyPairRSA(userID, pwd);
    keyManage.ExportPublicKey(userID, pwd);
    keyManage.ExportPrivateKey(userID, pwd);//私钥敏感信息不能导出
    keyManage.KeyStoreListKeys(pwd);

    QString tbu, tbp;
    tbu = QString::fromStdString(userID);
    tbp = QString::fromStdString(pwd);
    ui->textBrowser_3->setText("Key has been generated! The UserID is: " + tbu + ", The pwd is: " + tbp);


    //模式选择：原理展示/存储模式/调阅模式
    //用户界面
    while (true)
    {
        ModeManage modeManage;
        int Mode = modeManage.modeInput(global, user);
        Mode = 3;
        //modeManage.modeControl(Mode, user, pwd);
        //modeManage.modeControl(Mode, user, pwd);

        string keyringDir = conbineStrings(global.pathStringKey, "key-store");

        string newFile = ToString(userID) + "EncryptedMultiple.gpg"; //生成文件名为 userID + Encrypted.gpg
        string outputFile = conbineStrings(global.pathStringFile, newFile);

        char mykeyringDir[LINE_LEN];

        QString tempmykeyringdir = ui->lineEdit->text();
        mykeyringdir = tempmykeyringdir.toStdString();
        //string mykeyringdir="D:\\OpenPGP_File_Manage_show\\lenovo\\Key\\key-store";
        strcpy(mykeyringDir,mykeyringdir.c_str());



    /*
        printf("\nPrivate Key User Id (Used to sign outgoing messages and decrypt incoming messages): ");
        fgets(privateKey, LINE_LEN, stdin);
        privateKey[strlen(privateKey) - 1] = '\0';
        printf("Passphrase: ");
        fgets(passphrase, LINE_LEN, stdin);
        passphrase[strlen(passphrase) - 1] = '\0';
        printf("Recipient Key User Id (Used to encrypt outgoing messages): ");
        fgets(recipientKey, LINE_LEN, stdin);
        recipientKey[strlen(recipientKey) - 1] = '\0';
        printf("Signer Key User Id (Used to verify the signature of an incoming message): ");
        fgets(signerKey, LINE_LEN, stdin);
        signerKey[strlen(signerKey) - 1] = '\0';
    */
        //modeUserIDPwd.modeUserID = privateKey;
        //modeUserIDPwd.modePwd = passphrase;

        char passphrase2[LINE_LEN];
        char privateKey2[LINE_LEN];
        char recipientKey2[LINE_LEN];
        char signerKey2[LINE_LEN];

        QString aidtempMultiple = ui->lineEdit_8->text();
        aidMultiple = aidtempMultiple.toStdString();
        QString apwdtempMultiple = ui->lineEdit_7->text();
        apwdMultiple = apwdtempMultiple.toStdString();

        QString reciptempMultiple = ui->lineEdit_6->text();
        recipMultiple = reciptempMultiple.toStdString();
        QString signtempMultiple = ui->lineEdit_9->text();
        signMultiple = signtempMultiple.toStdString();

        strcpy(passphrase2,apwdMultiple.c_str());
        strcpy(privateKey2,aidMultiple.c_str());
        strcpy(recipientKey2,recipMultiple.c_str());
        strcpy(signerKey2,signMultiple.c_str());

        OpenPGP pgp;


        QString QinputfilepathAccess = ui->lineEdit_10->text();


        string outputfilepathMultipleDecrypt = "D:\\OpenPGP_File_Manage_show\\lenovo\\File\\" + userID + "Accessed.txt";
        QString QoutputfilepathMultipleDecrypt = QString::fromStdString(outputfilepathMultipleDecrypt);

        pgp.SetOverwrite(1);
        pgp.SetInputFile(QinputfilepathAccess);
        pgp.SetOutputFile(QoutputfilepathMultipleDecrypt);

        pgp.SetKeyCount(1);
        pgp.SetKeyKeyring(0, mykeyringDir);
        pgp.SetKeyUserId(0, privateKey2);
        pgp.SetKeyPassphrase(0, passphrase2);
        pgp.SetSignerKeyCount(1);
        pgp.SetSignerKeyKeyring(0, mykeyringDir);
        pgp.SetSignerKeyUserId(0, signerKey2);
        int ret_code_mul = pgp.DecryptAndVerifySignature();

        pgp.GetOutputFile();

        QString dataDecrypt;
        QFile fileDecrypt(QoutputfilepathMultipleDecrypt); //path是文件的路径
        if(!fileDecrypt.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            qDebug()<<"文件未打开!";
        }
        while(!fileDecrypt.atEnd())
        {
            QByteArray array = fileDecrypt.readLine();
            QString str(array);
           // qDebug() << str;
            dataDecrypt.append(str);
        }

        ui->textBrowser_2->setText("已授权用户调阅成功！解密文件存储位置："+QoutputfilepathMultipleDecrypt+"\n\n解密结果是："+dataDecrypt);


        break;
    }
}

```

#### 2.15 modemanage.cpp

```C++
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

#include "main.h"
#include "user.h"
#include "ModeManage.h"
#include "FileManage.h"
#include "global.h"

#include <sstream>

ModeManage::~ModeManage()
{

}

int ModeManage::modeInput(Global global, User user)
{
    modeGlobal.pathString = global.pathString;
    modeGlobal.pathStringFile = global.pathStringFile;
    modeGlobal.pathStringKey = global.pathStringKey;
    modeGlobal.pathStringUser = global.pathStringUser;

    while (true)
    {
        WriteLine("Select Mode: 1->Show Principle, 2->Store Files, 3->Access Files.");
        string mode;
        mode = "1";





        //cin >> mode;
        if (mode == "1")
        {
            WriteLine("Show Principle");
            return 1;
        }
        else if (mode == "2")
        {
            WriteLine("Store Files");
            WriteLine("存储文件的安全模式：1->单用户，2->多用户");
            while (true)
            {
                string subMode;
                cin >> subMode;
                if (subMode == "1")
                {
                    WriteLine("单用户模式");
                    WriteLine("请输入文件路径");
                    return 21;
                }
                else if (subMode == "2")
                {
                    WriteLine("多用户模式");

                    //user.User_Authorization();

                    WriteLine("请输入文件路径");
                    return 22;
                }
                else
                {
                    WriteLine("未知参数，请重新输入。");
                }
            }
        }
        else if (mode == "3")
        {
            WriteLine("Access Files");
            WriteLine("请输入文件路径(后缀为.gpg)");
            return 3;
        }
        else
        {
            WriteLine("未知参数，请重新输入。");
        }
    }
}
void ModeManage::modeControl(int mode, User user, string pwd)
{
    if (mode == 1)
    {
        //签名加密字符串
        FileManage fileManage;
        fileManage.SignAndEncryptString(pwd, user.getUserID(), modeGlobal.pathStringKey);

        //解密并验证签名
        //fileManage.DecryptAndVerifyString("a", pwd, user.getUserID());

        WriteLine("--------------");

    }
    else if (mode == 21)
    {
        //******************************************************************
        /*string filePath;
        WriteLine("21-test");
        getline(cin, filePath);
        while (true)
        {
            if (!_access(filePath.c_str(), 0))
            {
                FileManage fileManage;

                string outputFile = fileManage.SignAndEncryptSingle(pwd, filePath, user.getUserID(), modeGlobal.pathStringFile, modeGlobal.pathStringKey);
                bool check = fileManage.VerifySingle(pwd, outputFile, user.getUserID(), modeGlobal.pathStringFile, modeGlobal.pathStringKey);
                if (check)
                {
                    string temp = "文件存储成功，并由用户" + user.getUsername() + "签名，在" + outputFile + "中";//username???
                    WriteLine(temp);
                }
                else
                {
                    //cleardeletfile outputfile
                    WriteLine("21-test-exp2");
                }
                WriteLine("--------------");
                break;
            }
            else
            {
                WriteLine("文件不存在，请重新输入文件路径");
                getline(cin, filePath);
            }
        }*/
        /******************************************************************
    }
    else if (mode == 22)
    {
        /******************************************************************
        string filePath;
        getline(cin, filePath);
        while (true)
        {
            if (!_access(filePath.c_str(), 0))
            {
                FileManage fileManage;
                string outputFile = fileManage.SignAndEncryptMultiple(pwd, filePath, user.getAllUsers(),user.getUserID(), modeGlobal.pathStringFile, modeGlobal.pathStringKey);
                bool check = fileManage.Verify(pwd, outputFile, user.getAllUsers(), user.getUserID(), modeGlobal.pathStringFile, modeGlobal.pathStringKey);
                if (check)
                {
                    string temp = "文件存储成功，并由用户" + user.getUsername() + "签名，在" + outputFile + "中";//username???
                    WriteLine(temp);
                }
                else
                {
                    //cleardeletfile outputfile
                }
                WriteLine("--------------");
                break;
            }
            else
            {
                WriteLine("文件不存在，请重新输入文件路径");
                getline(cin, filePath);
            }
        }
        //******************************************************************/
    }
    else if (mode == 3)
    {

    }
    else
    {
        WriteLine("未知错误。");
    }
}

```

#### 2.16 user.cpp

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgp.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qipworksopenpgpkey.h"
#include "D:\preopengpg\IPWorks-OpenPGP-2022-C++-Edition-2\include\qt\qopenpgp.h"

#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib\\ipworksopenpgp22.lib")
#pragma comment(lib,"D:\\preopengpg\\IPWorks-OpenPGP-2022-C++-Edition-2\\lib64\\ipworksopenpgp22.lib")

#include <vector>
#include <Windows.h>
#include <iostream>
using namespace std;

#include <functional>
#include "main.h"
#include "user.h"

User::User()
{
    //GetUserName();
/*
* 此C++代码使用Windows API检索当前用户的安全标识符（SID），然后使用LookupAccountSid（）获取与该SID关联的用户名和域名，然后将其打印到控制台。
*
* 在C++代码中，szUserName和szDomainName是字符数组，用于存储LookupAccountSid（）函数检索到的用户名和域名。
* 调用LookupAccountSid（）时，函数会将检索到的用户名和域名分别写入szUserName和szDomainName提供的缓冲区。缓冲区的大小分别作为dwUserNameSize和dwDomainNameSize传入。
* 调用LookupAccountSid（）后，szUserName和szDomainName缓冲区用于使用printf（）将当前用户名以“domain\\username”格式打印到控制台。
*
* 在这个修改后的代码中，我们将szUserName和szDomainName的类型更改为wchar_t，这是Windows API函数使用的宽字符类型。
* 我们还将两个缓冲区的大小计算更改为wchar_t，而不是char。
* 最后，我们使用wprintf（）将当前用户名打印到控制台，使用%s格式说明符和宽字符串szDomainName和szUserName。
*/
    HANDLE hToken;
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        DWORD dwLengthNeeded;
        if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &dwLengthNeeded) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            PTOKEN_USER pTokenUser = (PTOKEN_USER)GlobalAlloc(GPTR, dwLengthNeeded);
            if (pTokenUser != NULL)
            {
                if (GetTokenInformation(hToken, TokenUser, pTokenUser, dwLengthNeeded, &dwLengthNeeded))
                {
                    SID_NAME_USE sidNameUse;

                    wchar_t szUserName[256];
                    DWORD dwUserNameSize = sizeof(szUserName);
                    wchar_t szDomainName[256];

                    DWORD dwDomainNameSize = sizeof(szDomainName);
                    PSID pSid = pTokenUser->User.Sid;
                    if (LookupAccountSid(NULL, pSid, szUserName, &dwUserNameSize, szDomainName, &dwDomainNameSize, &sidNameUse))
                    {
                        wprintf(L"Current user: %s\\%s\n", szDomainName, szUserName);
                        //printf("Current user: %s\\%s\n", szDomainName, szUserName);

                        username = WcharToString(szUserName);
                        sid = pSid;
                        if (!ConvertSidToStringSidW(sid, &stringSid))
                        {
                            //wmic useraccount get name, sid 指令可在cmd窗口查看本机各用户的sid
                            std::cout << "Failed to convert to string: error code " << GetLastError() << std::endl;
                            FreeSid(sid);
                            return;
                        }
                        userID = ToString(hash<LPWSTR>{}(stringSid));

                        currentUserInfo();
                    }
                }
                GlobalFree(pTokenUser);
            }
        }
        CloseHandle(hToken);
    }
}

void User::currentUserInfo()
{
    WriteLine("Current User: ");
    WriteLine(username);
    cout << sid << endl;
    std::wcout << stringSid << std::endl;

    WriteLine(userID);
}

string User::getUsername()
{
    return username;
}

PSID User::getSid()
{
    return sid;
}

LPWSTR User::getStringSid()
{
    return stringSid;
}

string User::getUserID()
{
    return userID;
}

User::~User()
{

}



```

#### 2.17 logindialog.ui

```html
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>LoginDialog</class>
 <widget class="QDialog" name="LoginDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1206</width>
    <height>733</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <widget class="QPushButton" name="pushButton">
   <property name="geometry">
    <rect>
     <x>520</x>
     <y>480</y>
     <width>151</width>
     <height>51</height>
    </rect>
   </property>
   <property name="text">
    <string>立即体验</string>
   </property>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

#### 2.18 mainwindow.ui

```html
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1196</width>
    <height>732</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <widget class="QWidget" name="centralWidget">
   <widget class="QPushButton" name="pushButton">
    <property name="geometry">
     <rect>
      <x>180</x>
      <y>230</y>
      <width>201</width>
      <height>71</height>
     </rect>
    </property>
    <property name="text">
     <string>[模式一：原理展示]
真实性认证和字符串加解密</string>
    </property>
   </widget>
   <widget class="QLineEdit" name="lineEdit">
    <property name="geometry">
     <rect>
      <x>150</x>
      <y>20</y>
      <width>971</width>
      <height>21</height>
     </rect>
    </property>
   </widget>
   <widget class="QLineEdit" name="lineEdit_2">
    <property name="geometry">
     <rect>
      <x>150</x>
      <y>60</y>
      <width>151</width>
      <height>21</height>
     </rect>
    </property>
   </widget>
   <widget class="QLineEdit" name="lineEdit_3">
    <property name="geometry">
     <rect>
      <x>420</x>
      <y>60</y>
      <width>151</width>
      <height>21</height>
     </rect>
    </property>
   </widget>
   <widget class="QLineEdit" name="lineEdit_4">
    <property name="geometry">
     <rect>
      <x>710</x>
      <y>60</y>
      <width>141</width>
      <height>21</height>
     </rect>
    </property>
   </widget>
   <widget class="QLineEdit" name="lineEdit_5">
    <property name="geometry">
     <rect>
      <x>970</x>
      <y>60</y>
      <width>151</width>
      <height>21</height>
     </rect>
    </property>
   </widget>
   <widget class="QTextBrowser" name="textBrowser">
    <property name="geometry">
     <rect>
      <x>150</x>
      <y>330</y>
      <width>430</width>
      <height>321</height>
     </rect>
    </property>
   </widget>
   <widget class="QTextBrowser" name="textBrowser_2">
    <property name="geometry">
     <rect>
      <x>690</x>
      <y>330</y>
      <width>430</width>
      <height>321</height>
     </rect>
    </property>
   </widget>
   <widget class="QLabel" name="label">
    <property name="geometry">
     <rect>
      <x>20</x>
      <y>20</y>
      <width>131</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>密钥文件地址：(Q)</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_2">
    <property name="geometry">
     <rect>
      <x>20</x>
      <y>60</y>
      <width>121</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>用户A ID：(W)</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_3">
    <property name="geometry">
     <rect>
      <x>310</x>
      <y>60</y>
      <width>111</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>用户A密码：(E)</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_4">
    <property name="geometry">
     <rect>
      <x>580</x>
      <y>60</y>
      <width>121</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>被授权人ID：(R)</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_5">
    <property name="geometry">
     <rect>
      <x>860</x>
      <y>60</y>
      <width>101</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>签名者ID：(T)</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_6">
    <property name="geometry">
     <rect>
      <x>310</x>
      <y>100</y>
      <width>111</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>用户B密码：(U)</string>
    </property>
   </widget>
   <widget class="QLineEdit" name="lineEdit_6">
    <property name="geometry">
     <rect>
      <x>710</x>
      <y>100</y>
      <width>141</width>
      <height>21</height>
     </rect>
    </property>
   </widget>
   <widget class="QLineEdit" name="lineEdit_7">
    <property name="geometry">
     <rect>
      <x>420</x>
      <y>100</y>
      <width>151</width>
      <height>21</height>
     </rect>
    </property>
   </widget>
   <widget class="QLineEdit" name="lineEdit_8">
    <property name="geometry">
     <rect>
      <x>150</x>
      <y>100</y>
      <width>151</width>
      <height>21</height>
     </rect>
    </property>
   </widget>
   <widget class="QLineEdit" name="lineEdit_9">
    <property name="geometry">
     <rect>
      <x>970</x>
      <y>100</y>
      <width>151</width>
      <height>21</height>
     </rect>
    </property>
   </widget>
   <widget class="QLabel" name="label_7">
    <property name="geometry">
     <rect>
      <x>860</x>
      <y>100</y>
      <width>101</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>签名者ID：(O)</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_8">
    <property name="geometry">
     <rect>
      <x>20</x>
      <y>100</y>
      <width>101</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>用户B ID：(Y)</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_9">
    <property name="geometry">
     <rect>
      <x>580</x>
      <y>100</y>
      <width>121</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>被授权人ID：(I)</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_10">
    <property name="geometry">
     <rect>
      <x>190</x>
      <y>200</y>
      <width>191</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>请先输入参数{Q,W,E,P}</string>
    </property>
   </widget>
   <widget class="QPushButton" name="pushButton_2">
    <property name="geometry">
     <rect>
      <x>430</x>
      <y>230</y>
      <width>201</width>
      <height>71</height>
     </rect>
    </property>
    <property name="text">
     <string>[模式二：单用户存储调阅]
真实性认证和文件加解密</string>
    </property>
   </widget>
   <widget class="QPushButton" name="pushButton_3">
    <property name="geometry">
     <rect>
      <x>670</x>
      <y>230</y>
      <width>201</width>
      <height>71</height>
     </rect>
    </property>
    <property name="text">
     <string>[模式三：多用户存储调阅]
真实性认证和文件加解密</string>
    </property>
   </widget>
   <widget class="QPushButton" name="pushButton_4">
    <property name="geometry">
     <rect>
      <x>920</x>
      <y>230</y>
      <width>201</width>
      <height>71</height>
     </rect>
    </property>
    <property name="text">
     <string>[模式四：多用户调阅]
调阅权限判定（四类用户）</string>
    </property>
   </widget>
   <widget class="QLineEdit" name="lineEdit_10">
    <property name="geometry">
     <rect>
      <x>230</x>
      <y>150</y>
      <width>891</width>
      <height>21</height>
     </rect>
    </property>
   </widget>
   <widget class="QLabel" name="label_11">
    <property name="geometry">
     <rect>
      <x>20</x>
      <y>130</y>
      <width>211</width>
      <height>71</height>
     </rect>
    </property>
    <property name="text">
     <string>模式一：输入字符串
模式二：输入待加密文件地址
模式三：输入调阅文件的地址
(P)</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_12">
    <property name="geometry">
     <rect>
      <x>430</x>
      <y>200</y>
      <width>201</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>请先输入参数{Q,W,E,R,T,P}</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_13">
    <property name="geometry">
     <rect>
      <x>680</x>
      <y>200</y>
      <width>161</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>请先输入所有参数</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_14">
    <property name="geometry">
     <rect>
      <x>920</x>
      <y>200</y>
      <width>201</width>
      <height>20</height>
     </rect>
    </property>
    <property name="text">
     <string>请先输入参数{Q,W,E,R,T,P}</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_15">
    <property name="geometry">
     <rect>
      <x>20</x>
      <y>330</y>
      <width>121</width>
      <height>71</height>
     </rect>
    </property>
    <property name="text">
     <string>加密信息
真实性认证信息:</string>
    </property>
   </widget>
   <widget class="QLabel" name="label_16">
    <property name="geometry">
     <rect>
      <x>600</x>
      <y>330</y>
      <width>81</width>
      <height>71</height>
     </rect>
    </property>
    <property name="text">
     <string>解密信息
调阅信息：</string>
    </property>
   </widget>
   <widget class="QTextBrowser" name="textBrowser_3">
    <property name="geometry">
     <rect>
      <x>30</x>
      <y>220</y>
      <width>111</width>
      <height>91</height>
     </rect>
    </property>
   </widget>
  </widget>
  <widget class="QMenuBar" name="menuBar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>1196</width>
     <height>23</height>
    </rect>
   </property>
  </widget>
  <widget class="QToolBar" name="mainToolBar">
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
  </widget>
  <widget class="QStatusBar" name="statusBar"/>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

