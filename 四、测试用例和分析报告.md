# 四、测试用例和分析报告

在此，一并展现参数的输入方法。

#### 4.1 欢迎界面与主界面

欢迎界面设计：

![image-20230421194647324](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230421194647324.png)

主界面设计：

![image-20230421194658601](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230421194658601.png)

#### 4.2 模式一、原理展示

**进行真实性认证和字符串的加解密。**

在输入了密钥文件地址、用户A输入了ID和密码以后，成功进行对字符串的加密和真实性认证，并进行解密。

分别输出在左右两侧。

**（注：中间模式选择左边的小方块，展示了每一次运行，都会生成一个ID和密码对，可以使用此ID和密码进行检验。）**

![image-20230421194749020](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230421194749020.png)

#### 4.3 模式二、单用户存储调阅

进行单用户的真实性认证和对文件的加解密。

用户A输入自己的ID、密码和签名、授权信息以后，自己能够加密存储文件，并且进行真实性认证、调阅并解密自己的文件。

![image-20230421195055425](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230421195055425.png)

#### 4.4 模式三、多用户存储调阅

真实性认证和多用户文件加解密。

用户A能够授权给用户B，使用户B获取调阅权限，能够进行真实性认证和解密操作。

![image-20230421195258919](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230421195258919.png)

#### 4.5 模式四、多用户调阅

有调阅权限用户能够调阅相应的文件。

![image-20230421195522706](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230421195522706.png)

#### 4.6 文件的生成展示

![image-20230421195555233](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230421195555233.png)

#### 4.7 敏感信息的覆盖核心代码

```c++
#include <iostream>
#include <windows.h>
#include <string>
#include <cstring>
#include <vector>
using namespace std;

int main() 
{
    size_t size = inputfilepathEncryptSingle.length();
    std::vector<wchar_t> buffer(inputfilepathEncryptSingle.size() + 1);
    MultiByteToWideChar(CP_ACP, 0, inputfilepathEncryptSingle.c_str(), -1, buffer.data(), static_cast<int>(buffer.size()));

    // 打开文件句柄
    HANDLE hFile = CreateFile(buffer.data(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to open file." << std::endl;
    }

    // 创建文件映射对象
    HANDLE hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hMapFile == NULL) {
        std::cerr << "Failed to create file mapping object." << std::endl;
        CloseHandle(hFile);
    }

    // 映射文件到进程地址空间
    LPVOID lpMapView = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (lpMapView == NULL) {
        std::cerr << "Failed to map view of file." << std::endl;
        CloseHandle(hMapFile);
        CloseHandle(hFile);
    }

    // 从内存中读取文件
    char* pBuffer = static_cast<char*>(lpMapView);
    std::cout << "Content of the file:" << std::endl;
    std::cout << pBuffer << std::endl;



    // 覆盖文件映射的地址空间
    SecureZeroMemory(lpMapView, GetFileSize(hFile, NULL));

    // 关闭文件映射
    UnmapViewOfFile(lpMapView);
    CloseHandle(hMapFile);

    // 关闭文件句柄
    CloseHandle(hFile);

    std::cout << "Succeeded in overwriting the mapped view of the file!" << std::endl;
    return 0;
    
    // 打开文件句柄
    HANDLE hFile = CreateFile(TEXT("D:\\masm\\111.asm"), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to open file." << std::endl;
        return 1;
    }

    // 创建文件映射对象
    HANDLE hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hMapFile == NULL) {
        std::cerr << "Failed to create file mapping object." << std::endl;
        CloseHandle(hFile);
        return 1;
    }

    // 映射文件到进程地址空间
    LPVOID lpMapView = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (lpMapView == NULL) {
        std::cerr << "Failed to map view of file." << std::endl;
        CloseHandle(hMapFile);
        CloseHandle(hFile);
        return 1;
    }

    // 从内存中读取文件
    char* pBuffer = static_cast<char*>(lpMapView);
    std::cout << "Content of the file:" << std::endl;
    std::cout << pBuffer << std::endl;

    // 覆盖文件映射的地址空间
    SecureZeroMemory(lpMapView, GetFileSize(hFile, NULL));

    // 关闭文件映射
    UnmapViewOfFile(lpMapView);
    CloseHandle(hMapFile);

    // 关闭文件句柄
    CloseHandle(hFile);

    std::cout << "Succeeded in overwriting the mapped view of the file!" << std::endl;
    return 0;
    
}

```

